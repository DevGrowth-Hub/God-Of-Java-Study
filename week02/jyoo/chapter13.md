# 인터페이스와 추상클래스, enum
### 메서드 내용이 없는 interface
- 자바에서 .class 파일을 만들 수 있는것은 클래스만 있는게 아니다. -> interface 와 abstract 클래스가 존재함.
- 이를 파악하기 위해선 `시스템을 만드는 절차`를 알아야함
  - 어떤 시스템을 개발하든 간에 `방법론`을 사용하여 개발됨.
    - 방법론: 시스템을 어떻게 만들 것인지에 대한 절차를 설명하고, 어떤 문서(산출물)을 작성해야 하는지를 정리해 놓은 공통 절차.
    - 일반적인 절차:
      1. 분석
        * 어떻게 개발하기를 원하는지 확인하는 요구사항 분석. 
      2. 설계
         * 프로그램을 어떻게 만들지 설계하는 단계
         * 어떤 메서드를 만들지, 데이터는 어떻게 저장할지 등 세부적인 것들을 정리
      3. 개발 및 테스트
         * 설계에서 만들기로 한 것들을 개발하는 단계.
      4. 시스템 릴리즈
         * 사용자들에게 제공하는 단계. 이후 운영/유지보수 단계를 거치며 문제를 해결 
  - 위 방법론이 나온 이유는, 설계 단계에서 인터페이스를 만들어 두면, 개발할 떄 메서드의 이름을 어떻게 할 것인지, 매개 변수를 어떻게 할지를 일일이 고민하지 않아도 된다.
    - 각 개발자의 역량에 따라 메서드의 이름 / 매개 변수 명이 차이가 나는데 이러한 차이를 줄일 수도 있다.
- interface 와 abstract 클래스를 사용하는 이유:
  - 설계시 선언해 두면 개발할 때 기능의 구현에만 집중할 수 있음
  - 개발자의 역량에 따른 메서드 / 매개변수명의 격차를 줄일 수 있다.
  - 공통적인 인터페이스와 abstract 클래스를 선언해 놓으면, 선언과 구현의 구분이 가능하다.

### final 예약어
- 이 예약어가 붙은 클래스는 상속받을 수 없다
  - final 로 선언된 클래스 A 에 대해 B extends A 는 불가하다는 의미
- 이 예약어가 붙은 메서드도 마찬가지로 overriding 할 수 없다
- 이 예약어가 붙은 변수는 변경할 수 없다.
  - 정말 불가한가? -> 그렇지는 않다. reflection 을 통해 우회하는 방법이 있다.
    - JDK 17 이전까지.
    - 왜 이러한 코드를 리플렉션에 남겨놓은 걸까?
      - JLS 에서 명시하는 케이스는 deserialization 으로, 역직렬화시 final로 선언된 값을 바꿀 수 있어야만 원하는 동작의 보장이 가능하기 때문이라고 한다. ([JLS-17.5.3](https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.5.3))

### Enum 클래스
- 모든 enum 클래스는 java.lang.Enum 을 상속받고 있다 (클래스의 Object 처럼) 
- java 1.5 에서 처음 등장하였다.