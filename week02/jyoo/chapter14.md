# Ch.14 다 배운 것 같지만, 예외라는 중요한 것이 있어요.
- 자바으 모든 사전정의된 예외는 Exception 클래스를 상속받는다.
- 먼저 선언한 catch 블록의 예외 클래스가 다음에 선언한 catch 블록의 부모에 속하면, 자식에 속하는 catch 블록은 절대 실행될 일이 없으므로 컴파일이 실행되지 않는다.
  - try-catch 의 제일 처음 잡는 예외가 Exception일 경우 뒤에 있는 어떤 예외도 터질 수 없기 때문에 컴파일에러가 난다!

### 예외의 종류는 세 가지다
    1. checked exception
    2. error
    3. runtime exception / unchecked exception

#### error:
  - 자바 프로그램 밖에서 발생한 예외. 
    - ex: 서버의 디스크 고장 등 자바 프로그램이 제대로 동작하지 못하는 경우
    - Exception 클래스는 에러가 아니다! java.lang.Error 라는 다른 클래스가 존재하고, 모든 사전 정의된 에러는 이 클래스를 상속받는다.
    - 클래스의 이름이 Error 로 끝나면 에러고, Exception 일 경우 예외.
    - 저자는 예외의 종류로 넣고 싶지 않다고 하는데 이유가 뭘까? 예외와 오류는 어떤 차이가 있는걸까?
  - Error vs Exception
    - error: 
      - 프로그램 밖에서 발생함
      - 프로세스에 영향을 줌
      - 프로그램이 멈춤
      - 관련 클래스를 개발자가 손댈 필요도 없고, 손대어서도 안됨
    - exception:
      - 프로그램 안에서 발생
      - 쓰레드에만 영향을 줌
      - 프로그램이 멈추지 않음
      - Throwable (Exception 이 더 좋다.) 을 상속받는 신규 예외를 개발자가 직접 만들어 사용하는 것이 흔함

#### runtime exception
- 컴파일시에는 잡히지 않지만, 런타임시에 프로그램이 실행되면서 발생할 수 있는 예외 케이스

### 모든 예외의 할아버지 java.lang.Throwable 클래스
- 모든 예외에서 사용되는 메서드 제공
- printStackTrace() 메서드를 지양해야 하는 이유
  - 레벨에 따라 조장할 수도 없는데 너무 많은 로그가 남게되어 디버깅에 도움이 되지 않음
  - System.err 에 출력되어 로그 파일 / 모니터링 시스템에 연동되지 않음

### 메서드에 throw 사용관련하여
- 저자는 이미 throws 한 것을 다시 throws 하는 것은 좋은 습관이 아니라고 한다.
  - 가장 좋은 방법은 최초로 throws 하는 메서드에서 try-catch 처리

### 자바 예외 처리 전략
- 임의의 예외 클래스를 만들 때에는 반드시 try-catch 로 묶어줄 필요가 있을 경우에만 Exception 클래스를 확장
  - 일반적으로 실행시 처리할 수 있는 경우는 RuntimeException 을 확장
- catch 문 내에 아무런 작업없이 공백을 놔두면 예외 분석이 어려워지기에 로깅 등의 처리를 해줘야 함