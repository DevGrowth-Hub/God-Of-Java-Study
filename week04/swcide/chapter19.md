# 📘 자바의 신 VOL.2 – 1장: 이쯤에서 자바의 역사와 JVM에 대해서 알아보자

## 자바의 역사
- 탄생: 1991년 TV 상호작용 기술 개발을 위한 'Green' 프로젝트에서 시작됨.
- 이름: 처음엔 **'Oak'**였으나, 1995년에 **'Java'**로 변경.
- 모토: **WORA (Write Once, Run Anywhere)** - '한 번 작성하면 어디서든 실행된다'는 이식성을 강조.

## JDK의 플랫폼에 따른 차이
-  OpenJDK 외에 여러 배포판 존재(Oracle, Temurin, Corretto, Zulu, Semeru 등).
-  어떤 OS에서든 JDK는 동일한 Java API를 제공하지만, 내부 동작 구조는 배포판마다 다를 수 있음.

## JDK, J2SE, Java SE 외에 자바에서 사용되는 다른 용어들
- JDK (Java Development Kit): 개발 키트. JRE + 개발 도구
- JRE (Java Runtime Environment): 실행 환경. JVM + 표준 라이브러리. 실행 전용
- Java SE: 표준 사양/API 세트. OpenJDK·Oracle JDK 등 구현 존재
- J2SE (Java 2 SE): 과거 명칭(1.2~5.0). Java SE 6부터 ‘2’ 제거
- Java EE → Jakarta EE: 엔터프라이즈 사양. Java SE 위 웹,트랜잭션, 서블릿, JPA, JMS 등

## 자바 언어의 특징은 다음과 같다
### 1. 자바는 "단순하고. 객체지향이며, 친숙"해야 한다.
- 처음부터 **객체지향**을 중심으로 설계
- 개발에 필요한 기능을 **표준 라이브러리(API)**로 제공    (파일 I/O, 네트워크, 그래픽 UI 등)
- C++에 비해 **쉽고 빠르게 개발**할 수 있는 장점

### 2. 자바는 "견고하며, 보안상 안전"하다.
- 프로그램 실행 시 **메모리·오류 검사**를 수행
- **네트워크/분산 환경**에서 사용될 것을 전제로 **보안** 설계
- 다운로드한 코드 실행 시에도 동작을 검증·제한 가능    (신뢰성 있는 실행 환경 제공)

### 3. 자바는 "아키텍처에 중립적이어야 하며 포터블"해야 한다.
- 소스 코드를 **바이트코드**로 변환, **JVM**에서 실행 → OS/하드웨어와 무관
- **데이터 타입·연산 규칙**을 명확히 정의하여 **이식성** 보장

### 4. 자바는 "높은 성능"을 제공해야 한다.
- 실행 환경에서 **최적의 성능**을 낼 수 있도록 설계
- **자동 메모리 관리** 등 편의 기능이 성능에 영향을 줄 수 있으나  
  일반적인 환경에서는 **충분한 성능** 제공

### 5. 자바는 "인터프리트 언어이며, 스레드를 제공하고, 동적인 언어"이다.
- **바이트코드 해석 실행(인터프리트)** 방식을 채택
- 언어 차원에서 **멀티 스레드 환경** 제공
- **동적 로딩/연결**을 지원해 실행 중 필요한 클래스를 불러와 사용 가능

## JIT 컴파일러는 도대체 뭘까?
- JIT(Just-In-Time): 실행 시점에 **그때그때 코드 변환**을 수행하는 방식(동적 변환).
- 컴퓨터 프로그램 실행 방식 두 가지
    - **인터프리터 방식**: 실행할 때마다 바이트코드를 해석해 수행.
    - **정적 컴파일 방식**: 실행 전에 미리 기계어로 변환해 둠.
- 자바는 **두 방식을 혼합**해 사용: 인터프리터로 시작하고, **필요한(자주 실행되는) 코드**를 실행 중에 기계어로 바꿔 **재사용**.
- `javac`는 **바이트코드(.class)**까지만 만든다.  
  → “Compile once, Run anywhere”는 **바이트코드 한 번 만들면** 어느 환경에서나 사용할 수 있다는 뜻.  
  → 실제 기계어 변환은 **실행 시 JIT**가 담당.

---

## HotSpot은 또 뭐야?
- **HotSpot**: JDK에 포함된 **Oracle JVM**.
- **자주 실행되는 부분(핫스팟)**을 찾아 **집중 최적화**하는 실행 방식.
- **클라이언트/서버 모드** 제공
    - Client VM: 시작 속도와 메모리 절약 중점.
    - Server VM: 장시간 실행 시 성능 극대화 중점.
- 실행 예시(모드 지정):
    - `$ java -server Calculator`
    - `$ java -client Calculator`

---

## 자바의 GC는 어떻게 진행되나요?
- **GC(Garbage Collection)**: 더 이상 사용하지 않는 객체를 JVM이 자동 회수.
- **흐름(세대별 수집)**
    1) 새 객체는 **Eden** 영역에 생성.
    2) Eden이 차면 **Young GC(=Minor GC)** 수행 → 살아 있는 객체만 **Survivor** 영역으로 이동(Eden 비움).
    3) Young GC를 여러 번 거쳐 계속 살아남는 객체는 **Old** 영역으로 **승격**.
    4) Old 영역이 가득 차면 **Major/Full GC** 수행.

- **대표 GC 방식(본문 나열)**
    **- Serial GC
    - Parallel GC
    - Parallel Old(Old Generation Collector)
    - Concurrent Mark & Sweep Collector(CMS)


## ❓**
1. 전체 힙을 Young처럼 운영하면 장애가 이어질 확률이 높아지는 이유는?
2. Young/Eden·Survivor → Old 구조를 쓰는 이유는?  