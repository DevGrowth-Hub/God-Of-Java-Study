# 📘 자바의 신 VOL.2 – 4장: 자바랭 다음으로 많이 쓰는 애들은 컬렉션 - Part1(List)

## 자바 컬렉션
-  배열과 비슷하지만 크기가 동적으로 변하고, 다양한 기능들을 제공.

### 컬렉션의 특징
- 크기가 동적으로 변함
- 다양한 데이터 타입을 저장
- 편리한 메소드들을 제공
- 제네릭(Generic)을 사용하여 타입 안전성 보장

### 컬렉션의 주요 인터페이스
- **List**: 순서가 있고 중복을 허용
- **Set**: 순서가 없고 중복을 허용하지 않음
- **Map**: 키-값 쌍으로 데이터를 저장
- **Queue**: FIFO(First In First Out) 구조

## List 인터페이스와 그 동생들

### List의 주요 구현 클래스
- **ArrayList**: 배열 기반의 리스트, 조회가 빠름
- **LinkedList**: 연결 리스트 기반, 삽입/삭제가 빠름
- **Vector**: ArrayList와 유사하지만 동기화 지원
- **Stack**: Vector를 상속받아 LIFO 구조 구현

### List의 주요 메소드
- `add()`: 데이터 추가
- `get()`: 데이터 조회
- `remove()`: 데이터 삭제
- `size()`: 크기 반환
- `contains()`: 데이터 포함 여부 확인

## ArrayList에 대해서 파헤쳐보자

### ArrayList의 특징
- 배열 기반으로 구현
- 인덱스를 통한 빠른 접근
- 크기가 동적으로 변함
- 동기화되지 않음 (멀티스레드 환경에서 주의 필요)
- null 값 저장 가능

### ArrayList의 내부 구조
내부적으로 Object 배열을 사용하여 데이터를 저장, size 변수로 실제 데이터 개수를 관리.

### ArrayList의 동작 원리
- 초기 용량은 10
- 용량이 부족하면 약 1.5배로 증가
- 데이터 추가 시 배열 끝에 추가
- 중간 삽입 시 기존 데이터들을 이동

## ArrayList의 생성자는 3개다

**1. 기본 생성자**
- 초기 용량이 10인 빈 ArrayList 생성. 가장 일반적으로 사용되는 방식.

**2. 초기 용량을 지정하는 생성자**
- 지정한 크기만큼의 초기 용량을 가진 ArrayList 생성. 미리 용량을 알고 있다면 성능상 유리.

**3. 다른 Collection을 매개변수로 받는 생성자**
- 기존 Collection의 모든 데이터를 복사하여 새로운 ArrayList 생성.

## ArrayList에 데이터를 담아보자

**add() 메소드**
- `add(데이터)`: 리스트의 마지막 위치에 데이터 추가
- `add(인덱스, 데이터)`: 지정한 인덱스 위치에 데이터 삽입, 기존 데이터들은 뒤로 이동
- `addAll(Collection)`: 다른 Collection의 모든 요소를 한 번에 추가
- `addAll(인덱스, Collection)`: 특정 위치에 다른 Collection의 모든 요소 추가

**set() 메소드**
- `set(인덱스, 데이터)`: 기존 데이터를 새로운 데이터로 교체

## ArrayList에서 데이터를 꺼내자

**개별 데이터 조회**
- `get(인덱스)`: 특정 위치의 데이터를 조회, 시간복잡도 O(1)

**데이터 존재 여부 확인**
- `contains(데이터)`: 특정 데이터가 리스트에 있는지 확인
- `indexOf(데이터)`: 특정 데이터의 첫 번째 인덱스 반환 (없으면 -1)
- `lastIndexOf(데이터)`: 특정 데이터의 마지막 인덱스 반환

**전체 데이터 순회**
- 일반 for문: 인덱스를 사용한 접근
- 향상된 for문(for-each): 간단하고 읽기 쉬운 방식
- Iterator: 안전한 순회 방식

**배열로 변환**
- `toArray()`: ArrayList를 Object 배열로 변환
- `toArray(T[] array)`: 지정한 타입의 배열로 변환

## ArrayList에 있는 데이터를 삭제하자

**remove() 메소드**
- `remove(인덱스)`: 특정 인덱스의 데이터를 삭제하고 삭제된 데이터 반환
- `remove(객체)`: 특정 객체와 equals()로 비교하여 일치하는 첫 번째 데이터 삭제

**여러 데이터 삭제**
- `removeAll(Collection)`: 지정한 Collection에 있는 모든 데이터를 삭제
- `retainAll(Collection)`: 지정한 Collection에 있는 데이터만 남기고 나머지 삭제
- `clear()`: 모든 데이터를 삭제

**조건부 삭제 (Java 8+)**
- `removeIf(조건)`: 특정 조건을 만족하는 데이터만 선택적으로 삭제

## Stack 클래스는 뭐가 다른데?

- Stack은 LIFO(Last In First Out) 구조를 구현한 클래스로, Vector를 상속받아 생성.

### Stack의 특징
- LIFO 구조: 마지막에 들어간 데이터가 먼저 나옴
- Vector를 상속받아 동기화 지원
- 주로 메소드 호출, 수식 계산, 되돌리기 기능 등에 사용

**Stack의 주요 메소드**
- `push(데이터)`: 데이터를 스택의 맨 위에 추가
- `pop()`: 맨 위 데이터를 제거하고 반환
- `peek()`: 맨 위 데이터를 조회만 하고 제거하지 않음
- `empty()`: 스택이 비어있는지 확인
- `search(데이터)`: 특정 데이터의 위치를 검색 (1부터 시작)

### Stack vs ArrayList
- **Stack**: LIFO 구조, 동기화 지원, 제한된 접근 방식
- **ArrayList**: 인덱스 접근, 동기화 미지원, 자유로운 접근

### 현대적인 대안
- Java에서는 Stack 대신 Deque 인터페이스(ArrayDeque 구현체) 사용을 권장. 더 나은 성능과 일관된 인터페이스를 제공.

## 정리하며

### List 선택 가이드
- **ArrayList**: 조회가 많고 순차적 추가/삭제가 주요 용도
- **LinkedList**: 중간 삽입/삭제가 빈번한 경우
- **Vector**: 멀티스레드 환경에서 동기화가 필요한 경우
- **Stack**: LIFO 구조가 필요한 특별한 경우

### 성능 비교
| 연산 | ArrayList | LinkedList | Vector |
|------|-----------|------------|--------|
| 조회 | O(1) | O(n) | O(1) |
| 끝에 추가 | O(1) | O(1) | O(1) |
| 중간 삽입 | O(n) | O(1) | O(n) |
| 삭제 | O(n) | O(1) | O(n) |


## ❓
1. stack 은 왜 Vector를 잘못 상속받은 클래스인가?