# Ch.23 자바랭 다음으로 많이 쓰는 애들은 컬랙션 - Part2 (Set과 Queue)

---

### Set이 왜 필요하지?
- 순서 상관없이, 어떤 데이터가 존재하는지를 확인하기 위한 용도로 많이 사용됨
  - 중복을 방지하고, 원하는 값이 포함되어 있는지를 확인하는 것이 주 용도.
- Set의 주요 구현체들:
  1. HashSet
     - 순서가 전혀 필요없는 데이터를 해시 테이블에 저장.
     - 가장 성능이 좋음
  2. TreeSet
     - 저장된 값에 따라 정렬되는 set. 
     - red-black 트리 타입으로 값이 저장됨
  3. LinkedHashSet
     - 연결된 목록 타입으로 구현된 해시 테이블에 데이터를 저장
     - 저장된 순서에 따라 값이 정렬됨
     - 성능이 가장 나쁨
  - 정렬 여부에 따라 성능 차이가 발생함.

---
### HashSet에 대해서 파헤쳐 보자
- hashSet의 생성자:
  - 기본 생성자
    - 16개의 공간과 0.75의 로드 팩터를 갖는 객체를 생성함.
  - `HashSet(int initialCapacity, float loadFactor)`
    - 지정한 공간과 로드팩터를 갖는 객체를 생성.
- <ins>_로드 팩터(load factor)란?_</ins>
  - (데이터의 개수/저장 공간) 을 의미.
  - 이 값이 크면 클 수록 저장 공간의 크기는 증가되고 해시 재정리 작업을 거쳐야하게 되므로 성능에 영향이 발생하게 됨.
  - 로드 팩터가 크면 클수록 공간은 널널해 지지만 데이터를 찾는 시간을 증가함.

---
### Queue는 왜 필요할까?
- LinkedList 의 경우, List 와 Queue & Deque를 둘 다 구현하는 구현체이다.
- FIFO 형태의 자료구조.

### LinkedList를 파헤쳐보자
- 각 노드가 자신의 앞/뒤에 존재하는 노드의 정보를 기억하여 처리하는 데이터 구조
  - 순차적으로 데이터를 빼는 경우에는 효울이 나쁨
  - 배열 중간에 있는 데이터가 지속적으로 삭제되고 추가되는 경우에는 메모리 공간 측면에서 훨씬 유리함.
    - 삭제된 데이터의 앞 뒤의 값을 연결시켜주면 되기 때문.
      - 위치를 맞추기 위한 데이터의 이동이 불필요해짐
- LinkedList의 생성자:
  - 각 데이터들이 앞뒤로 연결되는 구조이기 때문에, 크기를 지정하는 것이 불필요하다.
  - 기본 생성자
    - 비어있는 LinkedList를 생성함.
  - `LinkedList(Collection<? extends E> c)`
    - 매개변수로 받은 컬랙션 객체의 데이터를 LinkedList에 담는다.
- 여러 인터페이스들을 구현하다 보니, 같은 일을 하는 메서드들의 중복이 심하다.
  - 대체로 추가하려는 경우 add 가 붙은 메서드를 사용하는 것을 추천