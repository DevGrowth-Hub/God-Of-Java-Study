# Ch.19 이쯤에서 자바의 역사와 JVM에 대해서 알아보자
- JDK와 JRE의 차이:
  - JDK: Java Development Kit
  - JRE: Java Runtime Environment
  - JRE는 실행만을 위한 환경 -> 컴파일위한 프로그램들이 제외된 상태로 설치가 됨.

### 자바언어의 특징
1. simple, object-oriented and familiar
   - 처음부터 객체 지향적으로 설계됨
     - 그러나 개발자가 객체지향적으로 개발하지 않으면 장점이 없음
   - 많은 기능들을 이미 제공하는 라이브러리가 존재 (파일 I/O, 그래픽 UI등)
2. robust and secure
   - 컴파일시와 실행시에 문법적 오류에 관한 체크를 하고, 메모리 관리 모델이 단순(...)하고 포인터의 개념이 없다. -> 견고하고, 믿을 수 있는 (robust and reliable) 소프트웨어
   - 기본적으로 분산 환경에서 사용하기 위해 디자인됨. -> 보안은 분산환경에서 필수적 요소.
     - 네트워크 환경에서 다운로드 받은 승인받지 않은 프로그램은 실행이 불가 -> 자바 기술은 외부에서 침입을 불가하게함. 
3. architecture-neutral and portable
   - 아키텍쳐에 중립적인 바이트 코드를 생성해 다양한 하드웨어 아키텍처에서 수행할 수 있음. -> 버전만 동일하다면, 어떠한 환경에서도 자바를 실행할 수 있음
   - 기본 데이터 타입의 크기를 지정함 + 숫자 연산자에 대한 행위들을 정의해 둠으로, 개발자가 만든 프로그램은 어떤 플랫폼에서도 동일한 결과를 출력함.
     - JVM덕에 가능
4. executing with high performance
   - 실행 환경에서 최대한의 성능을 낼 수 있게 설계되었음.
     - 이 또한 JVM의 은혜
   - 자동화된 GC는 낮은 우선 순위의 쓰레드로 동작하기에 보다 높은 성능을 낼 수 있음
   - 필효한 경우 네이티브한 언어로 작성한 부분을 사용할 수도 있음.
5. interpreted, threaded, and dynamic
   - 자바 인터프리터 -> 자바 바이트 코드를 어떤 장비에서도 수행할 수 있게 해줌.
     - 🚨❗ **[의문점]** JVM이 아니라 인터프리터가..?
       - "어떤 장비에서도 실행"되는 이유 -> JVM(Java Virtual Machine)이 각 OS/CPU에 맞게 구현되어 있기 때문. 
         - 인터프리터는 JVM 안의 한 구성 요소일 뿐, 플랫폼 독립성을 보장하는 주체는 “JVM + 표준 라이브러리”. 개발자는 자바 소스코드를 작성 → 바이트코드로 컴파일 (.class) 각 장비에 맞는 JVM이 바이트코드를 읽음 JVM 내부의 인터프리터(또는 JIT)가 실제 해당 플랫폼의 기계어로 변환 후 실행
         - 인터프리터 자체가 `.class 파일(바이트코드)을 읽어서 즉시 해석하여 실행하는 프로그램` 을 의미하며, 이는 JVM 의 구성요소.
         - 이때 자주 사용되는 바이트코드를 기계어로 변환해 캐싱하는 것이 **JIT 의 역할**
           - 대부분의 JVM은 인터프리터 + JIT 혼합구조
     - 이로 인해 컴파일 -> 링크 -> 테스트 사이클을 빠른 환경을 구축가능
   - 멀티 스레드 환경을 제공하기에, 동시에 여러 작업을 수행가능. -> 매우 빠른 사용 환경 제공
   - 컴파일시 매우 엄격한 정적 점검을 수행한 후 실행시 동적으로 필요한 프로그램들을 링크 시킴.

### JIT 컴파일러는 도대체 뭘까
- Just-In-Time 의 약자로, 이 컴파일러는 .net 에서도 활용된다.
- 동적변환을 담당하는 컴파일러라고 보면된다 (컴파일시에 동작하진 않는다.)
- 자주 사용되는 바이트 코드들을 컴퓨터가 알어먹을 수 있는 언어로 변환하는 작업을 담당한다.
  - HotSpot JVM 기준 "자주 사용되는 바이트 코드"의 기준:
    - 메서드 호출 카운터: 약 10,000번 호출되면 JIT 대상
    (Client VM: 1,500번, Server VM: 10,000번-옵션 조정 가능)
    - 루프 카운터: 기본 15,000번 backedge 실행 시 JIT 대상. 
      - 실행 중인 루프도 중간에 네이티브 코드로 교체하는 OSR(On-Stack Replacement) 발동
    - `-XX:CompileThreshold=` 옵션으로 조절 가능

### HotSpot은 또 뭐야?
- JDK 1.3 부터 공식 지원된 기능
- JVM의 구현체로, Oracle이 만들었음. 
  - Oracle JDK, OpenJDK에서 기본 JVM으로 사용됨
- HotSpot은 서버 & 클라이언트 두가지로 분기되나, 클라이언트 hotspot은 아주 옛날 클라이언트가 대체적으로 1 CPU로 돌아던 시절에 만들어진 유물이라, 현대의 대부분의 PC에서 구동시 JVM은 HotSpot 서버 컴파일러를 사용할 것이다.
  - 서버 컴퍼일러는 사용하는 기준:
    - 2개 이상의 물리 코어
    - 2GB 이상의 물리 메모리

### 자바의 GC 수행 방식
#### 자바의 Heap 메모리 영역
- Young Generation (신세대 영역)
  - Eden: 새롭게 생성된 객체들이 먼저 할당됨. 
  - Survivor 영역 (From/To): Minor GC 시 Eden에서 살아남은 객체들이 이동하며, 두 영역 사이를 교대로 사용.
- Old Generation (구세대 영역)
  - Survivor 영역을 여러 번 살아남은 객체들이 이 구세대 영역으로 승격. 
  - 여기서 Major GC 또는 Full GC가 발생하면 전 영역의 비활성 객체를 제거.
- GC 흐름
  - Eden이 가득 차면 Minor GC 발생 → 살아남은 객체는 Survivor로 이동.
  - Survivor에서 일정 횟수 이상 살아남거나 공간 부족 시 객체는 Old Generation으로 이동.
  - Old Generation이 꽉 차면 Major / Full GC 실행 → 애플리케이션 스레드 멈추는 Stop-the-World 현상 발생.
- 자바 8 이후부터 PermGen 영역은 Metaspace로 대체되었으며, 이는 힙이 아닌 네이티브 메모리로 관리됩니다
