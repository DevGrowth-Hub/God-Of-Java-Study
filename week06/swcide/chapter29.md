# 📘 자바의 신 VOL.2 – 12장: Java 7에서 달라진 것들에는?

## Java 7에서는…
- **[JSR 336: Java SE 7 Release Contents](https://jcp.org/aboutJava/communityprocess/final/jsr336/index.html)**에 정리된 언어/라이브러리 개선 다수 도입
- 가독성, 예외 처리, 자원 관리, 제네릭 사용성 전반 개선

---

## 달라진 숫자 표현법!!!
- **2진수 리터럴**: 접두어 `0b`/`0B` 사용
- **8진수 리터럴**: 접두어 `0` 사용
- **16진수 리터럴**: 접두어 `0x`/`0X` 사용
- **숫자 구분자**: 숫자 사이에 `_`(언더스코어) 사용 가능
    - 제약: 숫자 **앞/뒤**, 소수점 바로 옆, 지수 표기(`e`, `p`) 바로 옆, 타입 접미사(`L`, `F`, `D`) 바로 앞/뒤에는 불가
    - **8진수**에서는 선행 `0` **뒤쪽 자리들 사이**에 사용 가능(예: `0_52` 형태처럼 **사이에**만 허용)

---

## switch 문장도 좀 확장되었대요
- `switch`에서 **`String`** 사용 가능
- `String`이 `null`이면 **NPE** 발생 가능 → 사전 null 체크 필요

---

## 제네릭은 다이아몬드를 쓰면 쉬워요
- 변수 선언에 타입이 있으면 생성자에는 **다이아몬드 `<>`**만 표기
- 다이아몬드 미사용·원시(raw) 타입 혼용 시 **컴파일 경고** 가능
- 메서드 내 객체 생성/비제네릭 생성 시 **타입 추론 한계** 유의

---

## Non reifiable varargs 타입
- **reifiable 타입**: 실행 시점에도 정확한 타입 정보가 남아 있는 타입  
  (예: 원시 타입, 비제네릭 타입, raw 타입, 무제한 와일드카드, reifiable 타입의 배열)
- **non-reifiable 타입**: **제네릭 타입 소거**로 인해 실행 시점에 구체 타입이 사라지는 타입  
  (예: `List<String>` 같은 매개변수화 타입, 제네릭 배열 등)
- **varargs(가변 인자)**는 호출 시 내부적으로 배열로 취급되는데, non-reifiable 제네릭과 결합하면  
  **컴파일러가 실행 시 타입 혼입을 완전히 막지 못해** 호출자 쪽에서 **다른 타입이 섞여 들어가는 잠재적 문제**(런타임 타입 불일치/예상치 못한 예외) 가능성이 있다.
- 안전하다고 판단되는 경우에 한해 메서드 선언부에 **`@SafeVarargs`** 사용 가능(***Java 7 기준**: `final`/`static` 메서드에만 적용).

---

## 예외도 이렇게 보완 되었답니다
- **멀티 캐치**: `catch (IOException | SQLException e)`처럼 `|`로 여러 예외를 **하나의 블록**에서 공통 처리

---

## Java 7부터는 꼭 안닫아도 되는 애들이 있어요
- **try-with-resources(TWR)** 도입
    - **`AutoCloseable`** 인터페이스 추가: TWR 블록 종료 시 `close()` **자동 호출**
    - `try (리소스1; 리소스2; …)` 형태로 **여러 리소스** 선언 가능(세미콜론으로 구분)
    - 기존 **`Closeable`**(I/O 계열)은 `AutoCloseable`을 확장하므로 **그대로 TWR에서 사용 가능**
    - `finally`에서 수동 `close()` 작성 불필요 → 누수/중첩 예외 처리 부담 감소
