# 📘 자바의 신 VOL.1 – 8장: 참조 자료형에 대해서 더 자세히 알아봅시다

---

## 1. 참조 자료형의 이해

- 자바의 기본형 8개를 제외한 모든 타입은 참조 자료형
- 대부분 `new` 연산자로 객체 생성  
  (`String`, 배열은 예외적으로 new 없이 생성 가능)
- `+` 연산자는 `String`에만 가능, 그 외 참조형은 `=`만 사용 가능

❓
- 자바에서 String은 왜 new 없이 객체 생성을 허용하는가?  
- String Constant Pool이 어떤 역할을 하며 메모리 효율성에 어떻게 기여하는가?
- 기본형과 참조형이 Stack/Heap에 저장되는 방식은 어떻게 다른가?  


---

## 2. 생성자 (Constructor)

- 클래스 인스턴스(객체) 생성을 위해 사용됨
- 반환 타입 없음, 이름은 클래스와 동일해야 생성자로 인식
- 기본 생성자: 매개변수 없는 생성자  
  → 다른 생성자가 존재할 경우 명시적으로 작성해야 함
- 여러 생성자 선언 가능 (오버로딩)  
  → 유지보수를 위해 꼭 필요한 생성자만 작성 권장
- DTO, VO와 같은 패턴을 통해 다양한 데이터를 묶어서 전달 가능

---

## 3. this 키워드

- 현재 객체 자신을 가리키는 참조 변수
- 인스턴스 변수와 매개변수 이름이 겹칠 때 명확한 구분을 위해 사용
- 생성자 내부에서 다른 생성자를 호출할 때도 사용됨

---

## 4. 메소드 오버로딩 (Overloading)

- 메소드 이름은 동일하지만, 매개변수의 타입, 개수, 순서가 다르면 다른 메소드로 인식
- 생성자도 오버로딩 가능
- "같은 역할은 같은 이름"을 모토로 활용

❓
- 반환 타입이나 접근 제어자가 오버로딩 조건에 포함되지 않는 이유는?
- 매개변수 이름만 다른 오버로딩이 불가능한 이유는?

---

## 5. 메소드의 종료 조건

- 다음 중 하나에 해당되면 종료됨:
    1. 모든 문장이 실행된 경우
    2. `return` 문 실행 시
        - `void`는 `return;` 사용 가능
        - 반환 타입이 있을 경우, `return 값;` 필수
    3. 예외 발생 (`throw`)

---

## 6. static 메소드와 static 블록

- **static 메소드**
    - 객체 생성 없이 클래스명으로 호출 가능
    - static 변수만 접근 가능, 인스턴스 필드는 직접 접근 불가

- **static 블록**
    - 클래스가 로딩될 때 단 한 번 실행
    - 클래스 초기화 작업에 활용됨

❓
- static 메소드를 함부로 쓰면 안 되는 이유는 무엇인가?  
- static 변수가 모든 객체에서 공유될 때 발생할 수 있는 문제점은?
- 클래스 참조만으로 static 블록이 실행되는 상황은?

---

## 7. 값 전달 vs. 참조 전달

- **Pass by Value**
    - 값이 복사되어 전달됨
    - 기본형은 이 방식 사용
    - 메소드 내에서 변경해도 원본에 영향 없음

- **Pass by Reference**
    - 객체의 참조(주소)가 전달됨
    - 메소드 내에서 객체 속성 변경 시 원본에도 반영됨

- **자바의 특성**
    - 자바는 모든 파라미터를 Pass by Value로 처리
    - 참조형은 "참조값(주소)의 복사"가 전달되기 때문에  
      마치 Pass by Reference처럼 보일 뿐

❓ 
- 참조형 파라미터를 메소드에서 새 객체로 재할당하면 원본 객체에 영향이 없는 이유는?
- String은 불변(Immutable)인데, Pass by Value로 넘길 때 어떤 주의점이 있는가?

---

## 8. 가변 인자 (Arbitrary Number of Arguments)

- 선언 형식: `타입... 변수명`
- 컴파일러는 내부적으로 배열로 처리
- 메소드당 1회만 사용 가능, 마지막 매개변수로만 선언 가능
- 대표 예시: `System.out.printf(String format, Object... args)`

---
